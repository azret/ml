using System;
using System.ComponentModel;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using static kernel32;
using System.Threading;

namespace nn {
    public static unsafe partial class F {
        public unsafe class Kernel : CriticalFinalizerObject, IDisposable {
            ~Kernel() {
                Dispose(disposing: false);
            }

            public void Dispose() {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing) {
            }
        }

        public static double no_loss(
            Tensor output,
            float[] target) {

            if (output is null) throw new ArgumentNullException(nameof(output));
            if (target is null) throw new ArgumentNullException(nameof(target));

            return 0;
        }

        public static double mse_loss(
            Tensor output,
            float[] target) {

            if (output is null) throw new ArgumentNullException(nameof(output));
            if (target is null) throw new ArgumentNullException(nameof(target));
            
            int N = target.Length;

            double sum = 0f;

            for (int n = 0; n < N; n++) {
                double diff = (output.data[n] - target[n]);
                sum += diff * diff;
                output.grad[n] = -(float)(2.0 * (diff / N));
            }

            return sum / N;
        }

        public static double binary_cross_entropy(
            Tensor output,
            float[] target) {

            const double EPSILON = 1e-12f;

            if (output is null) throw new ArgumentNullException(nameof(output));
            if (target is null) throw new ArgumentNullException(nameof(target));

            int N = target.Length;

            double sum = 0;

            for (int n = 0; n < N; n++) {

                if (output.data[n] < 0f || output.data[n] > 1f) throw new ArgumentOutOfRangeException(nameof(target), $"all elements of '{nameof(output)}' should be between 0 and 1");
                if (target[n] < 0f || target[n] > 1f) throw new ArgumentOutOfRangeException(nameof(target), $"all elements of '{nameof(target)}' should be between 0 and 1");

                sum += -(Math.Log(output.data[n] + EPSILON) * target[n] + (1.0 - target[n]) * Math.Log(1.0 - output.data[n] + EPSILON));

                output.grad[n] = -(float)((output.data[n] - target[n]) /
                    Math.Max(
                        (1.0 - output.data[n]) * output.data[n],
                        EPSILON) / N);
            }

            sum /= N;

            return sum;
        }

        public static unsafe void sigmoid_forward_cpu(
            float* _Out,       /* [N] */
            float* _In,        /* [N] */
            uint N) {

            for (int n = 0; n < N; n++) {
                var σ = 1.0f / (1.0f + (float)Math.Exp(-_In[n]));
                _Out[n] = σ;
            }
        }

        public static unsafe void sigmoid_backward_cpu(
            Tensor _Out,       /* [N] */
            Tensor _In,        /* [N] */
            uint N) {

            for (int n = 0; n < N; n++) {
                var σ = 1.0f / (1.0f + (float)Math.Exp(-_In.data[n]));
                _In.grad[n] += σ * (1.0f - σ) * _Out.grad[n];
            }
        }

        public static unsafe void matmul_forward_cpu(
            float* _Out,       /* [B, O] */
            float* _In,        /* [B, I] */
            float* _Weight,    /* [I, O] */
            float* _Bias,      /* [O] */
            uint B,
            uint I,
            uint O) {

            for (int b = 0; b < B; b++) {
                float* p_In_bt = _In + b * I;
                float* p_Out_bt = _Out + b * O;
                for (int o = 0; o < O; o++) {
                    double sum = _Bias == null ? 0 : _Bias[o];
                    for (int i = 0; i < I; i++) {
                        sum += _Weight[o * I + i] * p_In_bt[i];
                    }
                    p_Out_bt[o] = (float)sum;
                }
            }
        }

        public static void matmul_backward_cpu(
            Tensor _Out,       /* [B, O] */
            Tensor _In,        /* [B, I] */
            Tensor _Weight,    /* [I, O] */
            Tensor _Bias,      /* [O] */
            uint B,
            uint I,
            uint O) {

            for (int b = 0; b < B; b++) {
                for (int o = 0; o < O; o++) {
                    float δf = _Out.grad[b * O + o];
                    for (int i = 0; i < I; i++) {
                        _In.grad[b * I + i] += _Weight.data[o * I + i] * δf;
                    }
                }
            }

            for (int b = 0; b < B; b++) {
                for (int o = 0; o < O; o++) {
                    float δf = _Out.grad[b * O + o];
                    for (int i = 0; i < I; i++) {
                        _Weight.grad[o * I + i] += _In.data[b * I + i] * δf;
                    }
                    if (_Bias != null) {
                        _Bias.grad[o] += δf;
                    }
                }
            }
        }

        /// <summary>
        /// Base class for all MatMul kernels
        /// </summary>
        public unsafe abstract class MatMul : Kernel {
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public unsafe delegate void MatMul_Forward(
                float* _Out,       /* [B, O] */
                float* _In,        /* [B, I] */
                float* _Weight,    /* [I, O] */
                float* _Bias,      /* [O] */
                uint B,
                uint I,
                uint O);

            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public unsafe delegate void MatMul_Backward(
                Tensor _Out,       /* [B, O] */
                Tensor _In,        /* [B, I] */
                Tensor _Weight,    /* [I, O] */
                Tensor _Bias,      /* [O] */
                uint B,
                uint I,
                uint O);

            public abstract void forward(
                float* _Out,       /* [B, O] */
                float* _In,        /* [B, I] */
                float* _Weight,    /* [I, O] */
                float* _Bias,      /* [O] */
                uint B,
                uint I,
                uint O);

            public abstract void backward(
                Tensor _Out,       /* [B, O] */
                Tensor _In,        /* [B, I] */
                Tensor _Weight,    /* [I, O] */
                Tensor _Bias,      /* [O] */
                uint B,
                uint I,
                uint O);
        }

        /// <summary>
        /// A no-op implementation
        /// </summary>
        public unsafe class MatMulN : MatMul {
            public override unsafe void forward(
                float* _Out,
                float* _In,
                float* _Weight,
                float* _Bias,
                uint B,
                uint I,
                uint O) {
            }

            public override void backward(
                Tensor _Out,       /* [B, O] */
                Tensor _In,        /* [B, I] */
                Tensor _Weight,    /* [I, O] */
                Tensor _Bias,      /* [O] */
                uint B,
                uint I,
                uint O) {
            }
        }

        /// <summary>
        ///  A naive reference implementation
        /// </summary>
        public unsafe class MatMulA : MatMul {
            public override void forward(
                float* _Out,       /* [B, O] */
                float* _In,        /* [B, I] */
                float* _Weight,    /* [I, O] */
                float* _Bias,      /* [O] */
                uint B,
                uint I,
                uint O) {

                matmul_forward_cpu(
                    _Out,
                    _In,
                    _Weight,
                    _Bias,
                    B,
                    I,
                    O);
            }

            public override void backward(
                Tensor _Out,       /* [B, O] */
                Tensor _In,        /* [B, I] */
                Tensor _Weight,    /* [I, O] */
                Tensor _Bias,      /* [O] */
                uint B,
                uint I,
                uint O) {

                matmul_backward_cpu(
                    _Out,
                    _In,
                    _Weight,
                    _Bias,
                    B,
                    I,
                    O);
            }
        }

        /// <summary>
        /// Base class for all MatMul kernels written in raw assembly
        /// </summary>
        public abstract class MatMulC : MatMulA, IDisposable {
            IntPtr _p_Forward_Ptr;

            MatMul_Forward _Forward_Func;

            public MatMulC(byte[] _FORWARD_ASM_)
                : base() {
                if (_FORWARD_ASM_ is null) {
                    throw new ArgumentNullException(nameof(_FORWARD_ASM_));
                }
                _p_Forward_Ptr = VirtualAlloc(
                    IntPtr.Zero,
                    new IntPtr(_FORWARD_ASM_.Length),
                    AllocationTypes.Commit | AllocationTypes.Reserve,
                    MemoryProtections.ExecuteReadWrite);
                if (_p_Forward_Ptr == IntPtr.Zero) {
                    throw new OutOfMemoryException();
                }
                Marshal.Copy(
                    _FORWARD_ASM_,
                    0,
                    _p_Forward_Ptr,
                    _FORWARD_ASM_.Length);
                _Forward_Func = Marshal.GetDelegateForFunctionPointer<MatMul_Forward>(
                    _p_Forward_Ptr);
            }

            protected override void Dispose(bool disposing) {
                Interlocked.Exchange(ref _Forward_Func, null);
                IntPtr p_Mem = Interlocked.Exchange(ref _p_Forward_Ptr, IntPtr.Zero);
                if (p_Mem != IntPtr.Zero) {
                    bool success = VirtualFree(p_Mem, IntPtr.Zero, FreeTypes.Release);
                    if (!success && disposing) {
                        int lastWin32Error = Marshal.GetLastWin32Error();
                        throw new Win32Exception(lastWin32Error);
                    }
                }
            }

            public override unsafe void forward(
                float* _Out,       /* [B, O] */
                float* _In,        /* [B, I] */
                float* _Weight,    /* [I, O] */
                float* _Bias,      /* [O] */
                uint B,
                uint I,
                uint O) {

                _Forward_Func(
                    _Out,
                    _In,
                    _Weight,
                    _Bias,
                    B,
                    I,
                    O);
            }
        }

        /// <summary>
        /// Vectorized implementation of MatMul
        /// </summary>
        public class MatMulV : MatMulC {
            // cl /c /Gz /O2 /fp:fast /GS- /Qvec-report:2 MatMul.c
            public static byte[] _ASM_MatMul_FORWARD_ = new byte[] {
                0x4C, 0x89, 0x4C, 0x24, 0x20, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x41, 0x56, 0x48, 0x83, 0xEC, 0x60,
                0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xF2, 0x4C, 0x63, 0x94, 0x24, 0x98, 0x00,
                0x00, 0x00, 0x4C, 0x8B, 0xD9, 0x85, 0xC0, 0x0F, 0x8E, 0x6B, 0x02, 0x00, 0x00, 0x48, 0x63, 0x94,
                0x24, 0xA0, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x70, 0x45, 0x33, 0xC0, 0x48,
                0x89, 0x6C, 0x24, 0x58, 0x4C, 0x8B, 0xCA, 0x48, 0x89, 0x74, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24,
                0x48, 0x4C, 0x89, 0x64, 0x24, 0x40, 0x45, 0x33, 0xE4, 0x49, 0xC1, 0xE1, 0x02, 0x4C, 0x89, 0x6C,
                0x24, 0x38, 0x4C, 0x89, 0x4C, 0x24, 0x20, 0x4C, 0x89, 0x7C, 0x24, 0x30, 0x89, 0x8C, 0x24, 0x90,
                0x00, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x10, 0x48, 0x89, 0x44, 0x24, 0x18, 0x0F, 0x1F, 0x00,
                0x85, 0xD2, 0x0F, 0x8E, 0xC9, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x88, 0x00, 0x00, 0x00,
                0x4F, 0x8D, 0x3C, 0x18, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x45, 0x33, 0xED, 0x8B,
                0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x89, 0x4C, 0x24, 0x08, 0x49, 0x8B,
                0xD8, 0x48, 0x8B, 0xEA, 0x48, 0x89, 0x04, 0x24, 0x48, 0x8B, 0xF9, 0x0F, 0x1F, 0x44, 0x00, 0x00,
                0x48, 0x85, 0xD2, 0x74, 0x07, 0xF3, 0x0F, 0x10, 0x45, 0x00, 0xEB, 0x03, 0x0F, 0x57, 0xC0, 0x45,
                0x33, 0xC0, 0xF3, 0x41, 0x0F, 0x11, 0x07, 0x45, 0x85, 0xD2, 0x0F, 0x8E, 0xCD, 0x00, 0x00, 0x00,
                0x41, 0x83, 0xFA, 0x08, 0x0F, 0x82, 0xC3, 0x00, 0x00, 0x00, 0xF3, 0x42, 0x0F, 0x10, 0x24, 0x1B,
                0x45, 0x8D, 0x4A, 0xFF, 0x43, 0x8D, 0x04, 0x29, 0x48, 0x63, 0xC8, 0x49, 0x8D, 0x52, 0xFF, 0x48,
                0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x14, 0x93, 0x48, 0x8D, 0x04, 0x88, 0x4C,
                0x3B, 0xD8, 0x77, 0x09, 0x48, 0x3B, 0xD7, 0x0F, 0x83, 0x7F, 0x00, 0x00, 0x00, 0x8B, 0x84, 0x24,
                0x90, 0x00, 0x00, 0x00, 0x41, 0x03, 0xC1, 0x48, 0x63, 0xC8, 0x49, 0x8D, 0x04, 0x8E, 0x4C, 0x3B,
                0xD8, 0x77, 0x09, 0x4B, 0x8D, 0x04, 0xA6, 0x48, 0x3B, 0xD0, 0x73, 0x60, 0x0F, 0x57, 0xD2, 0x0F,
                0x57, 0xDB, 0x49, 0x8B, 0xD2, 0x4B, 0x8D, 0x0C, 0xA6, 0x48, 0x83, 0xE2, 0xF8, 0x48, 0x8B, 0xC7,
                0x0F, 0x10, 0x00, 0x49, 0x83, 0xC0, 0x08, 0x0F, 0x10, 0x09, 0x0F, 0x59, 0xC8, 0x0F, 0x10, 0x40,
                0x10, 0x48, 0x83, 0xC0, 0x20, 0x0F, 0x58, 0xD1, 0x0F, 0x10, 0x49, 0x10, 0x48, 0x83, 0xC1, 0x20,
                0x0F, 0x59, 0xC8, 0x0F, 0x58, 0xD9, 0x4C, 0x3B, 0xC2, 0x7C, 0xD5, 0x0F, 0x58, 0xD3, 0x0F, 0x28,
                0xCA, 0x0F, 0x12, 0xCA, 0x0F, 0x58, 0xCA, 0x0F, 0x28, 0xC1, 0x0F, 0xC6, 0xC1, 0xF5, 0xF3, 0x0F,
                0x58, 0xC8, 0xF3, 0x0F, 0x58, 0xE1, 0xF3, 0x42, 0x0F, 0x11, 0x24, 0x1B, 0x4C, 0x8B, 0x4C, 0x24,
                0x08, 0x48, 0x8B, 0x04, 0x24, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4D, 0x3B, 0xC2,
                0x7D, 0x42, 0xF3, 0x42, 0x0F, 0x10, 0x0C, 0x1B, 0x4B, 0x8D, 0x04, 0x01, 0x48, 0x8D, 0x0C, 0x81,
                0x4B, 0x8D, 0x04, 0x04, 0x49, 0x8D, 0x14, 0x86, 0x49, 0x8B, 0xC2, 0x49, 0x2B, 0xC0, 0x66, 0x90,
                0xF3, 0x0F, 0x10, 0x02, 0x48, 0x83, 0xC2, 0x04, 0xF3, 0x0F, 0x59, 0x01, 0x48, 0x83, 0xC1, 0x04,
                0xF3, 0x0F, 0x58, 0xC8, 0x48, 0x83, 0xE8, 0x01, 0x75, 0xE6, 0x48, 0x8B, 0x04, 0x24, 0xF3, 0x42,
                0x0F, 0x11, 0x0C, 0x1B, 0x48, 0x8B, 0x94, 0x24, 0x88, 0x00, 0x00, 0x00, 0x4A, 0x8D, 0x0C, 0x95,
                0x00, 0x00, 0x00, 0x00, 0x48, 0x03, 0xF9, 0x4D, 0x03, 0xCA, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00,
                0x00, 0x00, 0x49, 0x83, 0xC7, 0x04, 0x45, 0x03, 0xEA, 0x4C, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x83,
                0xC5, 0x04, 0x48, 0x83, 0xC3, 0x04, 0x48, 0x83, 0xE8, 0x01, 0x48, 0x89, 0x04, 0x24, 0x0F, 0x85,
                0x8C, 0xFE, 0xFF, 0xFF, 0x8B, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x44, 0x24, 0x10,
                0x8B, 0x94, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x18, 0x4C, 0x8B, 0x4C, 0x24,
                0x20, 0x41, 0x03, 0xCA, 0x4D, 0x03, 0xC1, 0x4D, 0x03, 0xE2, 0x89, 0x8C, 0x24, 0x90, 0x00, 0x00,
                0x00, 0x48, 0x83, 0xE8, 0x01, 0x4C, 0x89, 0x44, 0x24, 0x10, 0x48, 0x89, 0x44, 0x24, 0x18, 0x0F,
                0x85, 0x0B, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0x7C, 0x24, 0x30, 0x4C, 0x8B, 0x6C, 0x24, 0x38, 0x4C,
                0x8B, 0x64, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B,
                0x6C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x60, 0x41, 0x5E, 0xC3
            };
            public MatMulV()
                : base(_ASM_MatMul_FORWARD_) {
            }
        }

        /// <summary>
        /// Vectorized implementation of MatMul (AVX)
        /// </summary>
        public class MatMulAVX : MatMulC {
            // cl /c /Gz /O2 /fp:fast /arch:AVX /Qvec-report:2 MatMul.c
            public static byte[] forward_asm = new byte[] {
            0x4C, 0x89, 0x4C, 0x24, 0x20, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x60,
            0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xFA, 0x4C, 0x63, 0x94, 0x24, 0x98, 0x00,
            0x00, 0x00, 0x4C, 0x8B, 0xD9, 0x85, 0xC0, 0x0F, 0x8E, 0x5D, 0x02, 0x00, 0x00, 0x4C, 0x63, 0x84,
            0x24, 0xA0, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x70, 0x33, 0xD2, 0x48, 0x89,
            0x6C, 0x24, 0x58, 0x49, 0x8B, 0xD8, 0x48, 0x89, 0x74, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24, 0x48,
            0x4C, 0x89, 0x64, 0x24, 0x40, 0x45, 0x33, 0xE4, 0x48, 0xC1, 0xE3, 0x02, 0x4C, 0x89, 0x6C, 0x24,
            0x38, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x89, 0x8C, 0x24, 0x90, 0x00,
            0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0x44, 0x24, 0x18, 0x0F, 0x1F, 0x40, 0x00,
            0x45, 0x85, 0xC0, 0x0F, 0x8E, 0xBA, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00,
            0x00, 0x4A, 0x8D, 0x3C, 0x1A, 0x45, 0x33, 0xED, 0x41, 0x8B, 0xC0, 0x4D, 0x8B, 0xF1, 0x48, 0x89,
            0x44, 0x24, 0x08, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0xDA, 0x4C, 0x89, 0x0C, 0x24, 0x48, 0x8B, 0xF1,
            0x45, 0x33, 0xC0, 0x45, 0x85, 0xD2, 0x0F, 0x8E, 0xCA, 0x00, 0x00, 0x00, 0x41, 0x83, 0xFA, 0x08,
            0x0F, 0x82, 0xC0, 0x00, 0x00, 0x00, 0xC4, 0xA1, 0x7A, 0x10, 0x24, 0x1B, 0x45, 0x8D, 0x4A, 0xFF,
            0x43, 0x8D, 0x04, 0x29, 0x48, 0x63, 0xC8, 0x49, 0x8D, 0x52, 0xFF, 0x48, 0x8B, 0x84, 0x24, 0x80,
            0x00, 0x00, 0x00, 0x49, 0x8D, 0x14, 0x93, 0x48, 0x8D, 0x04, 0x88, 0x4C, 0x3B, 0xD8, 0x77, 0x09,
            0x48, 0x3B, 0xD6, 0x0F, 0x83, 0x81, 0x00, 0x00, 0x00, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00,
            0x41, 0x03, 0xC1, 0x48, 0x63, 0xC8, 0x49, 0x8D, 0x04, 0x8F, 0x4C, 0x3B, 0xD8, 0x77, 0x09, 0x4B,
            0x8D, 0x04, 0xA7, 0x48, 0x3B, 0xD0, 0x73, 0x62, 0xC5, 0xE8, 0x57, 0xD2, 0xC5, 0xE0, 0x57, 0xDB,
            0x49, 0x8B, 0xD2, 0x4B, 0x8D, 0x0C, 0xA7, 0x48, 0x83, 0xE2, 0xF8, 0x48, 0x8B, 0xC6, 0x66, 0x90,
            0xC5, 0xF8, 0x10, 0x08, 0xC5, 0xF0, 0x59, 0x09, 0xC5, 0xF0, 0x58, 0xD2, 0xC5, 0xF8, 0x10, 0x49,
            0x10, 0xC5, 0xF0, 0x59, 0x48, 0x10, 0x49, 0x83, 0xC0, 0x08, 0x48, 0x8D, 0x49, 0x20, 0x48, 0x8D,
            0x40, 0x20, 0xC5, 0xF0, 0x58, 0xDB, 0x4C, 0x3B, 0xC2, 0x7C, 0xD5, 0xC5, 0xE0, 0x58, 0xCA, 0xC5,
            0xF0, 0x12, 0xC1, 0xC5, 0xF8, 0x58, 0xD1, 0xC5, 0xE8, 0xC6, 0xC2, 0xF5, 0xC5, 0xEA, 0x58, 0xD0,
            0xC5, 0xDA, 0x58, 0xC2, 0xC4, 0xA1, 0x7A, 0x11, 0x04, 0x1B, 0x4C, 0x8B, 0x0C, 0x24, 0x48, 0x8B,
            0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4D, 0x3B, 0xC2, 0x7D, 0x45, 0xC4, 0xA1, 0x7A, 0x10, 0x14,
            0x1B, 0x4B, 0x8D, 0x04, 0x01, 0x48, 0x8D, 0x0C, 0x81, 0x4B, 0x8D, 0x04, 0x04, 0x49, 0x8D, 0x14,
            0x87, 0x49, 0x8B, 0xC2, 0x49, 0x2B, 0xC0, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xC5, 0xFA, 0x10, 0x02, 0x48, 0x8D, 0x52, 0x04, 0xC5, 0xFA, 0x59, 0x09, 0x48, 0x8D, 0x49, 0x04,
            0xC5, 0xEA, 0x58, 0xD1, 0x48, 0x83, 0xE8, 0x01, 0x75, 0xE6, 0xC4, 0xA1, 0x7A, 0x11, 0x14, 0x1B,
            0x48, 0x83, 0xBC, 0x24, 0x88, 0x00, 0x00, 0x00, 0x00, 0x74, 0x0D, 0xC5, 0xFA, 0x10, 0x07, 0xC4,
            0xC1, 0x7A, 0x58, 0x0E, 0xC5, 0xFA, 0x11, 0x0F, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00,
            0x4A, 0x8D, 0x04, 0x95, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x03, 0xCA, 0x48, 0x03, 0xF0, 0x45, 0x03,
            0xEA, 0x4C, 0x89, 0x0C, 0x24, 0x48, 0x83, 0xC7, 0x04, 0x48, 0x83, 0xC3, 0x04, 0x49, 0x83, 0xC6,
            0x04, 0x48, 0x83, 0x6C, 0x24, 0x08, 0x01, 0x0F, 0x85, 0x93, 0xFE, 0xFF, 0xFF, 0x8B, 0x8C, 0x24,
            0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24,
            0x10, 0x44, 0x8B, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x18, 0x48, 0x8B,
            0x5C, 0x24, 0x20, 0x41, 0x03, 0xCA, 0x48, 0x03, 0xD3, 0x4D, 0x03, 0xE2, 0x89, 0x8C, 0x24, 0x90,
            0x00, 0x00, 0x00, 0x48, 0x83, 0xE8, 0x01, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0x44, 0x24,
            0x18, 0x0F, 0x85, 0x19, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0x74, 0x24, 0x30, 0x4C, 0x8B, 0x6C, 0x24,
            0x38, 0x4C, 0x8B, 0x64, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50,
            0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x60, 0x41, 0x5F,
            0xC3 };

            public MatMulAVX()
                : base(forward_asm) {
            }
        }

        /// <summary>
        /// Vectorized implementation of MatMul (AVX2)
        /// </summary>
        public class MatMulAVX2 : MatMulC {
            // cl /c /Gz /O2 /fp:fast /arch:AVX2 /Qvec-report:2 MatMul.c
            public static byte[] forward_asm = new byte[] {
            0x4C, 0x89, 0x4C, 0x24, 0x20, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x50,
            0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xFA, 0x4C, 0x63, 0x94, 0x24, 0x88, 0x00,
            0x00, 0x00, 0x4C, 0x8B, 0xD9, 0x85, 0xC0, 0x0F, 0x8E, 0x45, 0x02, 0x00, 0x00, 0x4C, 0x63, 0x84,
            0x24, 0x90, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x60, 0x33, 0xD2, 0x48, 0x89,
            0x74, 0x24, 0x68, 0x49, 0x8B, 0xD8, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x4C, 0x89, 0x64, 0x24, 0x40,
            0x4C, 0x89, 0x6C, 0x24, 0x38, 0x45, 0x33, 0xED, 0x48, 0xC1, 0xE3, 0x02, 0x48, 0x89, 0x5C, 0x24,
            0x28, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x89, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0x54,
            0x24, 0x18, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x85, 0xC0, 0x0F, 0x8E, 0xB0, 0x01, 0x00, 0x00,
            0x33, 0xC9, 0x41, 0x8B, 0xC0, 0x4D, 0x8B, 0xE1, 0x89, 0x0C, 0x24, 0x48, 0x8B, 0xDA, 0x48, 0x89,
            0x44, 0x24, 0x10, 0x4A, 0x8D, 0x3C, 0x1A, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0x54, 0x24, 0x70, 0x4C,
            0x89, 0x4C, 0x24, 0x08, 0x48, 0x8B, 0xF2, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x45, 0x33, 0xC0, 0x45, 0x85, 0xD2, 0x0F, 0x8E, 0xC3, 0x00, 0x00, 0x00, 0x41, 0x83, 0xFA, 0x10,
            0x0F, 0x82, 0xB9, 0x00, 0x00, 0x00, 0xC4, 0xA1, 0x7A, 0x10, 0x24, 0x1B, 0x45, 0x8D, 0x4A, 0xFF,
            0x41, 0x8D, 0x04, 0x09, 0x48, 0x63, 0xC8, 0x49, 0x8D, 0x52, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x70,
            0x49, 0x8D, 0x14, 0x93, 0x48, 0x8D, 0x04, 0x88, 0x4C, 0x3B, 0xD8, 0x77, 0x09, 0x48, 0x3B, 0xD6,
            0x0F, 0x83, 0x7F, 0x00, 0x00, 0x00, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x41, 0x03, 0xC1,
            0x48, 0x63, 0xC8, 0x49, 0x8D, 0x04, 0x8F, 0x4C, 0x3B, 0xD8, 0x77, 0x09, 0x4B, 0x8D, 0x04, 0xAF,
            0x48, 0x3B, 0xD0, 0x73, 0x60, 0xC5, 0xE8, 0x57, 0xD2, 0xC5, 0xE0, 0x57, 0xDB, 0x49, 0x8B, 0xD2,
            0x4B, 0x8D, 0x0C, 0xAF, 0x48, 0x83, 0xE2, 0xF0, 0x48, 0x8B, 0xC6, 0x0F, 0x1F, 0x44, 0x00, 0x00,
            0xC5, 0xFC, 0x10, 0x08, 0xC4, 0xE2, 0x75, 0xB8, 0x11, 0xC5, 0xFC, 0x10, 0x48, 0x20, 0xC4, 0xE2,
            0x75, 0xB8, 0x59, 0x20, 0x49, 0x83, 0xC0, 0x10, 0x48, 0x8D, 0x49, 0x40, 0x48, 0x8D, 0x40, 0x40,
            0x4C, 0x3B, 0xC2, 0x7C, 0xDB, 0xC5, 0xE4, 0x58, 0xC2, 0xC5, 0xFF, 0x7C, 0xC8, 0xC5, 0xF7, 0x7C,
            0xD1, 0xC4, 0xE3, 0x7D, 0x19, 0xD0, 0x01, 0xC5, 0xF8, 0x58, 0xC2, 0xC5, 0xDA, 0x58, 0xC0, 0xC4,
            0xA1, 0x7A, 0x11, 0x04, 0x1B, 0x4C, 0x8B, 0x4C, 0x24, 0x08, 0x48, 0x8B, 0x54, 0x24, 0x70, 0x4D,
            0x3B, 0xC2, 0x7D, 0x3A, 0xC4, 0xA1, 0x7A, 0x10, 0x0C, 0x1B, 0x4B, 0x8D, 0x04, 0x01, 0x48, 0x8D,
            0x0C, 0x82, 0x4B, 0x8D, 0x04, 0x28, 0x49, 0x8D, 0x14, 0x87, 0x49, 0x8B, 0xC2, 0x49, 0x2B, 0xC0,
            0x48, 0x8D, 0x52, 0x04, 0xC5, 0xFA, 0x10, 0x01, 0x48, 0x8D, 0x49, 0x04, 0xC4, 0xE2, 0x79, 0xB9,
            0x4A, 0xFC, 0x48, 0x83, 0xE8, 0x01, 0x75, 0xE8, 0xC4, 0xA1, 0x7A, 0x11, 0x0C, 0x1B, 0x48, 0x83,
            0x7C, 0x24, 0x78, 0x00, 0x74, 0x0E, 0xC5, 0xFA, 0x10, 0x07, 0xC4, 0xC1, 0x7A, 0x58, 0x0C, 0x24,
            0xC5, 0xFA, 0x11, 0x0F, 0x8B, 0x0C, 0x24, 0x4A, 0x8D, 0x04, 0x95, 0x00, 0x00, 0x00, 0x00, 0x48,
            0x8B, 0x54, 0x24, 0x70, 0x41, 0x03, 0xCA, 0x4D, 0x03, 0xCA, 0x89, 0x0C, 0x24, 0x48, 0x03, 0xF0,
            0x4C, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x83, 0xC7, 0x04, 0x48, 0x83, 0xC3, 0x04, 0x49, 0x83, 0xC4,
            0x04, 0x48, 0x83, 0x6C, 0x24, 0x10, 0x01, 0x0F, 0x85, 0xA3, 0xFE, 0xFF, 0xFF, 0x8B, 0x8C, 0x24,
            0x80, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x78, 0x48, 0x8B, 0x54, 0x24, 0x18, 0x44, 0x8B,
            0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x5C, 0x24, 0x28,
            0x41, 0x03, 0xCA, 0x48, 0x03, 0xD3, 0x4D, 0x03, 0xEA, 0x89, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00,
            0x48, 0x83, 0xE8, 0x01, 0x48, 0x89, 0x54, 0x24, 0x18, 0x48, 0x89, 0x44, 0x24, 0x20, 0x0F, 0x85,
            0x23, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0x74, 0x24, 0x30, 0x4C, 0x8B, 0x6C, 0x24, 0x38, 0x4C, 0x8B,
            0x64, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x8B, 0x5C,
            0x24, 0x60, 0xC5, 0xF8, 0x77, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5F, 0xC3 };

            public MatMulAVX2()
                : base(forward_asm) {
            }
        }
    }
}